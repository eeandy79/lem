/* -LICENSE-START-
** Copyright (c) 2013 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <fcntl.h>
#include <csignal>

#include "linux/DeckLinkAPI.h"
#include "capture.h"
#include "decklinkconfig.h"

static pthread_mutex_t	g_sleepMutex;
static pthread_cond_t	g_sleepCond;
static int				g_videoOutputFile = -1;
static int				g_audioOutputFile = -1;
static bool				g_do_exit = false;

//static BMDConfig		m_config;

//static IDeckLinkInput*	m_deckLinkInput = NULL;

static unsigned long	g_frameCount = 0;

DeckLinkCaptureDelegate::DeckLinkCaptureDelegate(IDeckLinkInput *input, const BMDConfig &config) 
: m_refCount(1), m_deckLinkInput(input), m_config(config)
{
}

ULONG DeckLinkCaptureDelegate::AddRef(void)
{
	return __sync_add_and_fetch(&m_refCount, 1);
}

ULONG DeckLinkCaptureDelegate::Release(void)
{
	int32_t newRefValue = __sync_sub_and_fetch(&m_refCount, 1);
	if (newRefValue == 0)
	{
		delete this;
		return 0;
	}
	return newRefValue;
}

HRESULT DeckLinkCaptureDelegate::VideoInputFrameArrived(IDeckLinkVideoInputFrame* videoFrame, IDeckLinkAudioInputPacket* audioFrame)
{
	IDeckLinkVideoFrame*				rightEyeFrame = NULL;
	IDeckLinkVideoFrame3DExtensions*	threeDExtensions = NULL;
	void*								frameBytes;
	void*								audioFrameBytes;

	// Handle Video Frame
	if (videoFrame)
	{
		// If 3D mode is enabled we retreive the 3D extensions interface which gives.
		// us access to the right eye frame by calling GetFrameForRightEye() .
		if ( (videoFrame->QueryInterface(IID_IDeckLinkVideoFrame3DExtensions, (void **) &threeDExtensions) != S_OK) ||
			(threeDExtensions->GetFrameForRightEye(&rightEyeFrame) != S_OK))
		{
			rightEyeFrame = NULL;
		}

		if (threeDExtensions)
			threeDExtensions->Release();

		if (videoFrame->GetFlags() & bmdFrameHasNoInputSource)
		{
			printf("Frame received (#%lu) - No input signal detected\n", g_frameCount);
		}
		else
		{
			const char *timecodeString = NULL;
			if (m_config.m_timecodeFormat != 0)
			{
				IDeckLinkTimecode *timecode;
				if (videoFrame->GetTimecode(m_config.m_timecodeFormat, &timecode) == S_OK)
				{
					timecode->GetString(&timecodeString);
				}
			}

			printf("Frame received (#%lu) [%s] - %s - Size: %li bytes\n",
				g_frameCount,
				timecodeString != NULL ? timecodeString : "No timecode",
				rightEyeFrame != NULL ? "Valid Frame (3D left/right)" : "Valid Frame",
				videoFrame->GetRowBytes() * videoFrame->GetHeight());

			if (timecodeString)
				free((void*)timecodeString);

			if (g_videoOutputFile != -1)
			{
				videoFrame->GetBytes(&frameBytes);
				write(g_videoOutputFile, frameBytes, videoFrame->GetRowBytes() * videoFrame->GetHeight());

				if (rightEyeFrame)
				{
					rightEyeFrame->GetBytes(&frameBytes);
					write(g_videoOutputFile, frameBytes, videoFrame->GetRowBytes() * videoFrame->GetHeight());
				}
			}
		}

		if (rightEyeFrame)
			rightEyeFrame->Release();

		g_frameCount++;
	}

	// Handle Audio Frame
	if (audioFrame)
	{
		if (g_audioOutputFile != -1)
		{
			audioFrame->GetBytes(&audioFrameBytes);
			write(g_audioOutputFile, audioFrameBytes, audioFrame->GetSampleFrameCount() * m_config.m_audioChannels * (m_config.m_audioSampleDepth / 8));
		}
	}

	if (m_config.m_maxFrames > 0 && videoFrame && g_frameCount >= (unsigned long)m_config.m_maxFrames)
	{
		g_do_exit = true;
		pthread_cond_signal(&g_sleepCond);
	}

	return S_OK;
}

HRESULT DeckLinkCaptureDelegate::VideoInputFormatChanged(BMDVideoInputFormatChangedEvents events, IDeckLinkDisplayMode *mode, BMDDetectedVideoInputFormatFlags formatFlags)
{
	// This only gets called if bmdVideoInputEnableFormatDetection was set
	// when enabling video input
	HRESULT	result;
	char*	displayModeName = NULL;
	BMDPixelFormat	pixelFormat = bmdFormat10BitYUV;

	if (formatFlags & bmdDetectedVideoInputRGB444)
		pixelFormat = bmdFormat10BitRGB;

	mode->GetName((const char**)&displayModeName);
	printf("Video format changed to %s %s\n", displayModeName, formatFlags & bmdDetectedVideoInputRGB444 ? "RGB" : "YUV");

	if (displayModeName)
		free(displayModeName);

	if (m_deckLinkInput)
	{
		m_deckLinkInput->StopStreams();

		result = m_deckLinkInput->EnableVideoInput(mode->GetDisplayMode(), pixelFormat, m_config.m_inputFlags);
		if (result != S_OK)
		{
			fprintf(stderr, "Failed to switch video mode\n");
			goto bail;
		}

		m_deckLinkInput->StartStreams();
	}

bail:
	return S_OK;
}

static void sigfunc(int signum)
{
	if (signum == SIGINT || signum == SIGTERM)
		g_do_exit = true;

	pthread_cond_signal(&g_sleepCond);
}

IDeckLink* GetDeckLink(int deviceIdx) 
{
	HRESULT	result;
	IDeckLinkIterator* deckLinkIterator = NULL;
	IDeckLink* deckLink = NULL;
    int idx = deviceIdx;

	deckLinkIterator = CreateDeckLinkIteratorInstance();
	if (!deckLinkIterator) {
		fprintf(stderr, "This application requires the DeckLink drivers installed.\n");
        return NULL;
	}

	while ((result = deckLinkIterator->Next(&deckLink)) == S_OK) {
		if (idx== 0)
			break;
		--idx;
		deckLink->Release();
	}

	if (result != S_OK || deckLink == NULL) {
		fprintf(stderr, "Unable to get DeckLink device %u\n", deviceIdx);
	}

	if (deckLinkIterator != NULL) {
		deckLinkIterator->Release();
    }

    return deckLink;
}

bool IsFormatDetectionSupported(IDeckLink *deckLink) 
{
	IDeckLinkAttributes* deckLinkAttributes = NULL;
	bool formatDetectionSupported = false;
    bool rv = false;

    HRESULT	result = deckLink->QueryInterface(IID_IDeckLinkAttributes, (void**)&deckLinkAttributes);
    if (result == S_OK) {
        result = deckLinkAttributes->GetFlag(BMDDeckLinkSupportsInputFormatDetection, &formatDetectionSupported);
        if (result != S_OK || !formatDetectionSupported) {
            fprintf(stderr, "Format detection is not supported on this device\n");
        } else {
            rv = true; // only here is good
        }
    }

    if (deckLinkAttributes != NULL)
		deckLinkAttributes->Release();

    return rv;
}

IDeckLinkDisplayMode* GetDisplayMode(IDeckLinkInput *deckLinkInput, int modeIdx)
{
	IDeckLinkDisplayMode* displayMode = NULL;
	IDeckLinkDisplayModeIterator* displayModeIterator = NULL;
    int idx = modeIdx;

	HRESULT	result = deckLinkInput->GetDisplayModeIterator(&displayModeIterator);
	if (result != S_OK)
        return NULL;

	while ((result = displayModeIterator->Next(&displayMode)) == S_OK)
	{
		if (idx == 0)
			break;
		--idx;
		displayMode->Release();
	}

	if (result != S_OK || displayMode == NULL) {
        fprintf(stderr, "Unable to get display mode %d\n", modeIdx);
        if (displayMode) {
            displayMode->Release();
            displayMode = NULL;
        }
	}

	if (displayModeIterator != NULL)
		displayModeIterator->Release();

    return displayMode;
}

bool 
IsVideoModeSupported(IDeckLinkInput *deckLinkInput, IDeckLinkDisplayMode *displayMode, const BMDConfig &config)		
{
    bool rv = false;
	char* displayModeName = NULL;
	HRESULT	result;
	BMDDisplayModeSupport displayModeSupported;

	result = displayMode->GetName((const char**)&displayModeName);
	if (result != S_OK) {
		displayModeName = (char *)malloc(32);
		snprintf(displayModeName, 32, "[index %d]", config.m_displayModeIndex);
	}

	// Check display mode is supported with given options
    result = deckLinkInput->DoesSupportVideoMode(
            displayMode->GetDisplayMode(), 
            config.m_pixelFormat, 
            bmdVideoInputFlagDefault, 
            &displayModeSupported, NULL);

	if (result != S_OK || displayModeSupported == bmdDisplayModeNotSupported) {
		fprintf(stderr, "The display mode %s is not supported with the selected pixel format\n", displayModeName);
	} else {
        rv = true;
    }

	if (displayModeName != NULL)
		free(displayModeName);

    return rv;
}

int rundecklink(IDeckLinkInput *deckLinkInput, IDeckLinkDisplayMode *displayMode, BMDConfig &config)
{
	HRESULT							result;
	int								exitStatus = 1;

	pthread_mutex_init(&g_sleepMutex, NULL);
	pthread_cond_init(&g_sleepCond, NULL);

	signal(SIGINT, sigfunc);
	signal(SIGTERM, sigfunc);
	signal(SIGHUP, sigfunc);

	// Print the selected configuration
	config.DisplayConfiguration();

	// Block main thread until signal occurs
	while (!g_do_exit)
	{
		// Start capturing
		result = deckLinkInput->EnableVideoInput(displayMode->GetDisplayMode(), 
                config.m_pixelFormat, config.m_inputFlags);
		if (result != S_OK)
		{
			fprintf(stderr, "Failed to enable video input. Is another application using the card?\n");
			goto bail;
		}

		result = deckLinkInput->EnableAudioInput(bmdAudioSampleRate48kHz, 
                config.m_audioSampleDepth, config.m_audioChannels);
		if (result != S_OK)
			goto bail;

		result = deckLinkInput->StartStreams();
		if (result != S_OK)
			goto bail;

		// All Okay.
		exitStatus = 0;

		pthread_mutex_lock(&g_sleepMutex);
		pthread_cond_wait(&g_sleepCond, &g_sleepMutex);
		pthread_mutex_unlock(&g_sleepMutex);

		fprintf(stderr, "Stopping Capture\n");
		deckLinkInput->StopStreams();
		deckLinkInput->DisableAudioInput();
		deckLinkInput->DisableVideoInput();
	}

bail:
	return exitStatus;
}

